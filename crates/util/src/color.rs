// NOTE: GENERATED BY AI

use cosmic_text::Color;
use regex_lite::Regex;
use std::num::{ParseFloatError, ParseIntError};
use thiserror::Error;

#[derive(Debug, Error)]
pub enum ParseColorError {
    #[error("invalid color name")]
    InvalidName,
    #[error("invalid hex format")]
    InvalidHex,
    #[error("invalid color format")]
    InvalidFormat,
    #[error("value out of range")]
    OutOfRange,
    #[error("parse int error: {0}")]
    ParseInt(#[from] ParseIntError),
    #[error("parse float error")]
    ParseFloat(#[from] ParseFloatError),
}

lazy_static::lazy_static! {
    // static ref CSS_COLORS: HashMap<&'static str, [u8; 4]> = {
    //     let mut m = HashMap::new();
    //     m.insert("black", [0, 0, 0, 255]);
    //     m.insert("white", [255, 255, 255, 255]);
    //     m.insert("red", [255, 0, 0, 255]);
    //     m.insert("lime", [0, 255, 0, 255]);
    //     m.insert("blue", [0, 0, 255, 255]);
    //     m.insert("transparent", [0, 0, 0, 0]);
    //     // ...
    //     m
    // };

    static ref RGB_REGEX: Regex = Regex::new(
        r"(?i)^rgba?\(\s*(\d+%?)\s*,\s*(\d+%?)\s*,\s*(\d+%?)\s*(?:,\s*([\d.]+%?)\s*)?\)$"
    ).unwrap();

    static ref HSL_REGEX: Regex = Regex::new(
        r"(?i)^hsla?\(\s*(\d+\.?\d*)\s*,\s*(\d+\.?\d*)%\s*,\s*(\d+\.?\d*)%\s*(?:,\s*([\d.]+%?)\s*)?\)$"
    ).unwrap();

    pub static ref COLOR_BLACK: Color = Color::rgb(0, 0, 0);
    pub static ref COLOR_RED: Color = Color::rgb(255, 0, 0);
    pub static ref COLOR_GREEN: Color = Color::rgb(0, 255, 0);
    pub static ref COLOR_BLUE: Color = Color::rgb(0, 0, 255);
    pub static ref COLOR_WHITE: Color = Color::rgb(255, 255, 255);
    pub static ref COLOR_TRANSPARENT: Color = Color::rgba(0, 0, 0, 0);
}

pub fn parse_color(s: &str) -> Result<Color, ParseColorError> {
    parse_color_inner(s).map(|v| Color::rgba(v[0], v[1], v[2], v[3]))
}

fn parse_color_inner(s: &str) -> Result<[u8; 4], ParseColorError> {
    let s = s.trim().to_lowercase();

    // if let Some(&color) = CSS_COLORS.get(s.as_str()) {
    //     return Ok(color);
    // }

    // hex
    if let Some(hex) = s.strip_prefix('#') {
        return parse_hex(hex);
    }

    // rgb/rgba
    if s.starts_with("rgb") {
        return parse_rgb(&s);
    }

    // HSL/HSLA
    if s.starts_with("hsl") {
        return parse_hsl(&s);
    }

    Err(ParseColorError::InvalidFormat)
}

fn parse_hex(hex: &str) -> Result<[u8; 4], ParseColorError> {
    let len = hex.len();
    let mut chars = hex.chars();

    let (r_len, g_len, b_len, a_len) = match len {
        3 | 4 => (1, 1, 1, if len == 4 { 1 } else { 0 }),
        6 | 8 => (2, 2, 2, if len == 8 { 2 } else { 0 }),
        9 | 12 => (3, 3, 3, if len == 12 { 3 } else { 0 }),
        16 => (4, 4, 4, 4),
        _ => return Err(ParseColorError::InvalidHex),
    };

    let r = parse_hex_component(&chars.by_ref().take(r_len).collect::<String>(), r_len)?;
    let g = parse_hex_component(&chars.by_ref().take(g_len).collect::<String>(), g_len)?;
    let b = parse_hex_component(&chars.by_ref().take(b_len).collect::<String>(), b_len)?;
    let a = if a_len > 0 {
        parse_hex_component(&chars.take(a_len).collect::<String>(), a_len)?
    } else {
        255
    };

    Ok([r, g, b, a])
}

fn parse_hex_component(s: &str, digits: usize) -> Result<u8, ParseColorError> {
    let max_val = (1u32 << (digits * 4)) - 1;
    let value = u32::from_str_radix(s, 16)?;
    let scaled = ((value as f32 * 255.0) / max_val as f32).round() as u8;
    Ok(scaled)
}

fn parse_rgb(s: &str) -> Result<[u8; 4], ParseColorError> {
    let caps = RGB_REGEX
        .captures(s)
        .ok_or(ParseColorError::InvalidFormat)?;

    let r = parse_percent_or_byte(caps.get(1).unwrap().as_str())?;
    let g = parse_percent_or_byte(caps.get(2).unwrap().as_str())?;
    let b = parse_percent_or_byte(caps.get(3).unwrap().as_str())?;
    let a = if let Some(a_match) = caps.get(4) {
        parse_alpha(a_match.as_str())?
    } else {
        255
    };

    Ok([r, g, b, a])
}

fn parse_percent_or_byte(s: &str) -> Result<u8, ParseColorError> {
    if let Some(percent) = s.strip_suffix('%') {
        let value = percent.parse::<f32>()?;
        Ok((value.clamp(0.0, 100.0) * 2.55).round() as u8)
    } else {
        let value = s.parse::<u8>()?;
        Ok(value.clamp(0, 255))
    }
}

fn parse_alpha(s: &str) -> Result<u8, ParseColorError> {
    if let Some(percent) = s.strip_suffix('%') {
        let value = percent.parse::<f32>()?;
        Ok((value.clamp(0.0, 100.0) * 2.55).round() as u8)
    } else {
        let value = s.parse::<f32>()?;
        Ok((value.clamp(0.0, 1.0) * 255.0).round() as u8)
    }
}

fn parse_hsl(s: &str) -> Result<[u8; 4], ParseColorError> {
    let caps = HSL_REGEX
        .captures(s)
        .ok_or(ParseColorError::InvalidFormat)?;

    let h = caps[1].parse::<f32>()? % 360.0;
    let s = caps[2].parse::<f32>()?.clamp(0.0, 100.0) / 100.0;
    let l = caps[3].parse::<f32>()?.clamp(0.0, 100.0) / 100.0;

    let alpha = if let Some(a_match) = caps.get(4) {
        parse_alpha(a_match.as_str())?
    } else {
        255
    };

    let rgb = hsl_to_rgb(h, s, l);
    Ok([rgb[0], rgb[1], rgb[2], alpha])
}

fn hsl_to_rgb(h: f32, s: f32, l: f32) -> [u8; 3] {
    let c = (1.0 - (2.0 * l - 1.0).abs()) * s;
    let x = c * (1.0 - ((h / 60.0) % 2.0 - 1.0).abs());
    let m = l - c / 2.0;

    let (r, g, b) = match h {
        h if (0.0..60.0).contains(&h) => (c, x, 0.0),
        h if (60.0..120.0).contains(&h) => (x, c, 0.0),
        h if (120.0..180.0).contains(&h) => (0.0, c, x),
        h if (180.0..240.0).contains(&h) => (0.0, x, c),
        h if (240.0..300.0).contains(&h) => (x, 0.0, c),
        _ => (c, 0.0, x),
    };

    [
        ((r + m) * 255.0).round() as u8,
        ((g + m) * 255.0).round() as u8,
        ((b + m) * 255.0).round() as u8,
    ]
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_hex() {
        assert_eq!(parse_color_inner("#f00").unwrap(), [255, 0, 0, 255]);
        assert_eq!(parse_color_inner("#ff0000").unwrap(), [255, 0, 0, 255]);
        assert_eq!(parse_color_inner("#ff000080").unwrap(), [255, 0, 0, 128]);
        assert_eq!(parse_color_inner("#fff000000").unwrap(), [255, 0, 0, 255]); // 3 digits per channel
    }

    #[test]
    fn test_parse_rgb() {
        assert_eq!(
            parse_color_inner("rgb(255, 0, 0)").unwrap(),
            [255, 0, 0, 255]
        );
        assert_eq!(
            parse_color_inner("rgba(255, 0, 0, 0.5)").unwrap(),
            [255, 0, 0, 128]
        );
        assert_eq!(
            parse_color_inner("rgb(100%, 50%, 0%)").unwrap(),
            [255, 128, 0, 255]
        );
    }

    #[test]
    fn test_parse_hsl() {
        assert_eq!(
            parse_color_inner("hsl(0, 100%, 50%)").unwrap(),
            [255, 0, 0, 255]
        );
        assert_eq!(
            parse_color_inner("hsla(120, 100%, 50%, 0.5)").unwrap(),
            [0, 255, 0, 128]
        );
    }

    // #[test]
    // fn test_named_color() {
    //     assert_eq!(parse_color("red").unwrap(), [255, 0, 0, 255]);
    //     assert_eq!(parse_color("transparent").unwrap(), [0, 0, 0, 0]);
    // }
}
